<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java内存区域</title>
    <link href="/2024/01/12/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
    <url>/2024/01/12/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><ul><li>是一块较小的内存空间</li><li>字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li>分支、循环、跳转、异常、线程恢复都需要依赖这个计数器来完成</li><li>每条线程都有一个独立的程序计数器，是线程私有的内存区域</li><li>唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域</li><li>如果线程正在执行的是一个Java方法，记录的是正在执行的字节码指令的地址，如果正在执行native方法，记录的是undefined</li></ul><h3 id="2、Java虚拟机栈"><a href="#2、Java虚拟机栈" class="headerlink" title="2、Java虚拟机栈"></a>2、Java虚拟机栈</h3><ul><li><p>是线程私有的内存区域</p></li><li><p>每个方法执行都会创建一个栈帧，栈帧中存储了局部变量表、操作数栈、动态链接、方法出口等信息，方法从调用到执行完毕对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</p></li><li><p>线程请求的栈深度大于虚拟机所允许的最大深度，会抛出StackOverflowError异常；如果Java虚拟机栈支持动态扩展，当栈扩展时无法申请到足够的内存就会抛出OOM异常</p></li></ul><h4 id="2-1-局部变量表"><a href="#2-1-局部变量表" class="headerlink" title="2.1 局部变量表"></a>2.1 局部变量表</h4><ul><li>用于存放方法参数和方法内部定义的局部变量。</li><li>在Java程序被编译成class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量</li><li>以变量槽为最小单位，一个槽占用的内存空间由具体的实现决定，基本数据类型（除long和double）、reference、returnAddress（指向一条字节码指令的地址）占用一个槽，long和double占用2个槽</li><li>JVM通过索引定位的方法访问局部变量表，从0到最大的变量槽数。非static方法0号槽是this，其余的会按照参数列表、方法内部定义的变量顺序和作用域依次分配变量槽</li><li>为了尽可能的减少栈帧所占用的内存空间，局部变量表的变量槽是可以复用的，如果当前程序计数器的值已经超出了某个变量的作用域，这个变量对应的变量槽可以交给其他变量重用</li></ul><h4 id="2-2-操作数栈"><a href="#2-2-操作数栈" class="headerlink" title="2.2 操作数栈"></a>2.2 操作数栈</h4><h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><ul><li><p>线程私有的内存区域</p></li><li><p>为JVM使用到的本地方法服务</p></li><li><p>HotSpot将本地方法栈和虚拟机栈合二为一</p></li><li><p>在栈深度溢出和栈扩展失败时抛出StackOverflowError和OOM异常</p></li></ul><h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><ul><li><p>所有线程共享的一块内存区域</p></li><li><p>几乎所有的对象实例都在这里分配内存</p></li><li><p>没有内存完成对象分配，也无法扩展时抛出OOM异常</p></li></ul><h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><ul><li>线程共享的内存区域</li><li>存储已经被JVM加载的类型信息、常量、静态变量、即时编译器编译过的代码缓存等数据</li><li>如果方法区无法满足新的内存分配需求，将抛出OOM异常</li></ul><h3 id="6、运行时常量池"><a href="#6、运行时常量池" class="headerlink" title="6、运行时常量池"></a>6、运行时常量池</h3><ul><li>是方法区的一部分</li><li>存放编译期生成的各种字面量、符号引用和符号引用翻译出来的直接引用，运行期间可以通过String.intern方法将新的常量放入池中</li><li>无法再申请到内存时会抛出OOM异常</li></ul><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul><li>不是运行时数据区的一部分</li><li>受物理内存的限制抛出OOM异常</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
